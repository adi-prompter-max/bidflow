---
phase: 03-tender-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - prisma/seed.ts
  - prisma/seeders/tenders.ts
  - src/lib/tenders/scoring.ts
  - src/lib/tenders/queries.ts
  - src/lib/tenders/filters.ts
autonomous: true

must_haves:
  truths:
    - "Database contains 50+ realistic mock tenders across IT and Construction sectors"
    - "Relevance scoring produces 0-100 scores based on company sector, value, and tag match"
    - "Query layer returns filtered tenders with relevance scores sorted by relevance desc"
  artifacts:
    - path: "prisma/seeders/tenders.ts"
      provides: "Faker-based tender seed generator"
      contains: "faker"
    - path: "src/lib/tenders/scoring.ts"
      provides: "Weighted relevance scoring algorithm"
      exports: ["calculateRelevanceScore"]
    - path: "src/lib/tenders/queries.ts"
      provides: "Prisma queries with dynamic filtering"
      exports: ["getTenders", "getTenderById"]
    - path: "src/lib/tenders/filters.ts"
      provides: "Filter type definitions and Zod validation"
      exports: ["tenderFilterSchema", "TenderFilters"]
  key_links:
    - from: "src/lib/tenders/queries.ts"
      to: "src/lib/tenders/scoring.ts"
      via: "import calculateRelevanceScore"
      pattern: "calculateRelevanceScore"
    - from: "src/lib/tenders/queries.ts"
      to: "prisma.tender"
      via: "Prisma findMany with dynamic where"
      pattern: "prisma\\.tender\\.findMany"
    - from: "prisma/seed.ts"
      to: "prisma/seeders/tenders.ts"
      via: "import and call seedTenders"
      pattern: "seedTenders"
---

<objective>
Install TanStack Table and Faker, create Faker-based tender seed data (50 realistic tenders), build the relevance scoring algorithm, and implement the Prisma query layer with filtering support.

Purpose: Establish the data foundation and server-side logic that the tender list and detail UI will consume.
Output: Populated database with mock tenders, working scoring algorithm, and query functions ready for UI integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-tender-discovery/03-RESEARCH.md
@prisma/schema.prisma
@prisma/seed.ts
@src/lib/dal.ts
@src/lib/prisma.ts
@src/lib/validations/profile.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create Faker seed script for tenders</name>
  <files>
    package.json
    prisma/seeders/tenders.ts
    prisma/seed.ts
  </files>
  <action>
    1. Install dependencies:
       ```
       npm install @tanstack/react-table
       npm install --save-dev @faker-js/faker
       ```

    2. Create `prisma/seeders/tenders.ts` that generates 50 realistic mock tenders:
       - Use @faker-js/faker for realistic data
       - Split between IT (30) and Construction (20) sectors
       - Value ranges: IT tenders 50k-2M EUR, Construction 100k-5M EUR
       - Deadlines: spread across next 6 months (some already close to deadline for urgency)
       - Status: 45 OPEN, 3 CLOSED, 2 AWARDED (realistic mix)
       - Requirements field: JSON with `tags` array (matching capabilityTags patterns like "Cloud Services", "Cybersecurity", "Software Development", "Renovation", "Infrastructure", "New Build") and `experience` (years as number), `certifications` array
       - Documents field: JSON array with realistic document names (Technical Spec, Security Requirements, Tender Notice, etc.)
       - Titles should be realistic EU tender titles (use faker.company.catchPhrase() combined with sector-specific prefixes)
       - Descriptions should be 2-3 paragraphs of realistic tender descriptions
       - Export as `async function seedTenders()` that uses `prisma.tender.createMany({ skipDuplicates: true })`
       - Import PrismaClient in the file (same pattern as seed.ts)

    3. Update `prisma/seed.ts`:
       - Import `seedTenders` from `./seeders/tenders`
       - Delete existing non-demo tenders first (`prisma.tender.deleteMany({ where: { id: { not: { startsWith: 'tender-demo' } } } })`) to allow re-seeding
       - Call `await seedTenders()` after existing demo data creation
       - Keep all existing seed logic intact (demo user, company, certifications, projects, demo tenders, demo bid)
       - Add console.log for tender seeding result

    Important: The seeders directory does not exist yet - create it. Use `import { PrismaClient } from '@prisma/client'` and instantiate a new client in the seeder file, OR better, accept prisma as a parameter to avoid multiple connections.
  </action>
  <verify>
    Run `npx prisma db seed` and verify:
    - No errors
    - Console shows 50+ tenders created
    - Run `npx prisma studio` or a quick script to confirm tender count
  </verify>
  <done>Database contains 50+ Faker-generated tenders with realistic titles, descriptions, sectors, values, deadlines, requirements, and documents alongside existing demo data</done>
</task>

<task type="auto">
  <name>Task 2: Create filter types, scoring algorithm, and query layer</name>
  <files>
    src/lib/tenders/filters.ts
    src/lib/tenders/scoring.ts
    src/lib/tenders/queries.ts
  </files>
  <action>
    1. Create `src/lib/tenders/filters.ts`:
       - Define Zod schema `tenderFilterSchema` for validating filter params:
         - `sector`: optional string (enum-like: "IT" | "Construction" or empty for all)
         - `minValue`: optional number (coerced from string)
         - `maxValue`: optional number (coerced from string)
         - `deadline`: optional string (ISO date string, tenders with deadline >= this date)
         - `sort`: optional string (default "relevance", alternatives: "deadline", "value")
       - Export `TenderFilters` type inferred from the schema
       - Export helper function `parseFilters(searchParams: Record<string, string | string[] | undefined>): TenderFilters` that safely parses URL search params through the Zod schema (use safeParse, return defaults on failure)

    2. Create `src/lib/tenders/scoring.ts`:
       - Mark with `import 'server-only'` at top (scoring logic must not leak to client bundle)
       - Export `calculateRelevanceScore(tender: Tender, company: CompanyWithRelations | null): number`
       - Weighted scoring (sector: 40%, value: 20%, tags: 40%):
         - **Sector match (40 pts):** Full 40 if company.sectors includes tender.sector, 0 otherwise
         - **Value match (20 pts):** Compare tender.value against company's past project average value. Parse company project valueRange strings ("50k - 100k", "100k - 250k", etc.) to get midpoints, average them. If tender value is within 50% of average, full 20 pts. Within 100%, 10 pts. Otherwise 0.
         - **Tag match (40 pts):** Parse tender.requirements JSON to extract tags array. Calculate overlap with company.capabilityTags (case-insensitive). Score = 40 * (matchingTags / totalTenderTags). If no tender tags, give 0 for this component.
       - Return score clamped to 0-100
       - Handle edge cases: null company returns 0, no projects returns partial scoring (skip value component, redistribute to sector 50% / tags 50%)
       - Export type `TenderWithScore` that extends Tender with `relevanceScore: number`

    3. Create `src/lib/tenders/queries.ts`:
       - Mark with `import 'server-only'`
       - Import prisma from `@/lib/prisma`, scoring from `./scoring`, filters from `./filters`
       - Export `getTenders(filters: TenderFilters, userId: string): Promise<TenderWithScore[]>`:
         - Build dynamic `Prisma.TenderWhereInput` based on filters (see RESEARCH.md Pattern 4)
         - Default to status: 'OPEN' always
         - Fetch company with projects and certifications for scoring (`prisma.company.findUnique({ where: { ownerId: userId }, include: { projects: true, certifications: true } })`)
         - Map tenders with `calculateRelevanceScore`
         - Sort by relevance score descending by default, or by deadline/value based on sort filter
         - Return TenderWithScore[]
       - Export `getTenderById(id: string, userId: string): Promise<TenderWithScore | null>`:
         - Fetch single tender by ID
         - If not found, return null
         - Calculate relevance score using same company fetch
         - Return tender with score
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no TypeScript errors. Check that all imports resolve correctly. If the project has a build command, run `npm run build` to confirm no build errors.
  </verify>
  <done>Filter validation, relevance scoring (0-100 weighted), and Prisma query layer with getTenders and getTenderById are implemented with proper server-only marking and TypeScript types</done>
</task>

</tasks>

<verification>
1. `npm install` completes without errors (deps installed)
2. `npx prisma db seed` populates 50+ tenders
3. `npx tsc --noEmit` passes (no type errors)
4. All new files exist: prisma/seeders/tenders.ts, src/lib/tenders/scoring.ts, src/lib/tenders/queries.ts, src/lib/tenders/filters.ts
</verification>

<success_criteria>
- @tanstack/react-table and @faker-js/faker installed
- Database seeded with 50+ realistic mock tenders (IT and Construction)
- Relevance scoring algorithm produces 0-100 scores based on sector/value/tag matching
- Query layer supports dynamic filtering by sector, value range, and deadline
- All code is TypeScript-clean and server-only marked where appropriate
</success_criteria>

<output>
After completion, create `.planning/phases/03-tender-discovery/03-01-SUMMARY.md`
</output>
