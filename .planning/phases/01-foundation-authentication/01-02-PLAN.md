---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/auth.ts
  - src/lib/auth.config.ts
  - src/lib/dal.ts
  - src/actions/auth.ts
  - middleware.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/layout.tsx
  - src/components/auth/login-form.tsx
  - src/components/auth/signup-form.tsx
autonomous: true

must_haves:
  truths:
    - "User can create an account with email and password via signup form"
    - "User can log in with valid credentials and is redirected to dashboard"
    - "Invalid credentials show an error message without crashing"
    - "User session persists across browser refresh (cookie-based)"
    - "Unauthenticated users are redirected to login when accessing protected routes"
    - "User can log out from any page and is redirected to home"
  artifacts:
    - path: "src/lib/auth.ts"
      provides: "Auth.js v5 full configuration with Prisma adapter"
      exports: ["auth", "handlers", "signIn", "signOut"]
    - path: "src/lib/auth.config.ts"
      provides: "Edge-compatible auth config with credentials provider"
      exports: ["authConfig"]
    - path: "src/lib/dal.ts"
      provides: "Data Access Layer with session verification"
      exports: ["verifySession", "getUser"]
    - path: "src/actions/auth.ts"
      provides: "Server Actions for signup, login, logout"
      exports: ["signup", "login", "logout"]
    - path: "middleware.ts"
      provides: "Route protection middleware"
      contains: "auth as middleware"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page with form"
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Signup page with form"
    - path: "src/components/auth/login-form.tsx"
      provides: "Login form component with validation"
    - path: "src/components/auth/signup-form.tsx"
      provides: "Signup form component with validation"
  key_links:
    - from: "src/components/auth/login-form.tsx"
      to: "src/actions/auth.ts"
      via: "Server Action invocation"
      pattern: "login\\("
    - from: "src/components/auth/signup-form.tsx"
      to: "src/actions/auth.ts"
      via: "Server Action invocation"
      pattern: "signup\\("
    - from: "src/actions/auth.ts"
      to: "src/lib/auth.ts"
      via: "signIn/signOut imports"
      pattern: "import.*signIn.*from.*auth"
    - from: "src/lib/auth.ts"
      to: "src/lib/prisma.ts"
      via: "Prisma adapter connection"
      pattern: "PrismaAdapter\\(prisma\\)"
    - from: "src/lib/dal.ts"
      to: "src/lib/auth.ts"
      via: "Session verification"
      pattern: "auth\\(\\)"
    - from: "middleware.ts"
      to: "src/lib/auth.ts"
      via: "Auth middleware export"
      pattern: "auth as middleware"
---

<objective>
Implement the complete authentication system: Auth.js v5 configuration with credentials provider, Data Access Layer for secure session verification, server actions for signup/login/logout, middleware for route protection, and auth UI pages (login and signup) with validated forms.

Purpose: Enable users to create accounts, log in, maintain sessions, and log out — satisfying AUTH-01 and AUTH-02 requirements. Defense-in-depth approach per research: middleware for UX redirects, DAL for actual security.
Output: Working auth flow where users can sign up, log in (session persists across refresh), access protected routes, and log out.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Auth.js v5 with credentials provider, DAL, and middleware</name>
  <files>
    src/lib/auth.config.ts
    src/lib/auth.ts
    src/lib/dal.ts
    middleware.ts
    src/app/api/auth/[...nextauth]/route.ts
  </files>
  <action>
    1. Create `src/lib/auth.config.ts` (edge-compatible config):
       - Import NextAuthConfig type from next-auth
       - Configure pages: signIn -> '/login'
       - Configure authorized callback:
         - Check if user is logged in via `auth?.user`
         - Protect `/dashboard` routes: redirect unauthenticated to /login
         - Allow public routes: /, /login, /signup
         - If logged in user visits /login or /signup, redirect to /dashboard
       - Configure Credentials provider:
         - Accept email (string, email format) and password (string, min 8 chars)
         - In authorize function: parse with Zod, look up user by email using Prisma directly (import prisma from @/lib/prisma), compare password with bcryptjs
         - Return user object (id, name, email) on success, null on failure
         - IMPORTANT: Do NOT import from dal.ts in auth.config.ts (circular dependency risk)

    2. Create `src/lib/auth.ts` (full config with adapter):
       - Import NextAuth from 'next-auth'
       - Import PrismaAdapter from '@auth/prisma-adapter'
       - Import authConfig from './auth.config'
       - Import prisma from './prisma'
       - Export { auth, handlers, signIn, signOut } from NextAuth({
           ...authConfig,
           adapter: PrismaAdapter(prisma),
           session: { strategy: 'jwt' },
           // NOTE: Using JWT strategy because credentials provider does not support database sessions
           // in Auth.js v5. This is a known limitation. JWT is encrypted and stored in httpOnly cookie.
           callbacks: {
             jwt({ token, user }) {
               if (user) { token.id = user.id }
               return token
             },
             session({ session, token }) {
               if (token?.id) { session.user.id = token.id as string }
               return session
             }
           }
         })
       - IMPORTANT: Credentials provider in Auth.js v5 does NOT work with database sessions.
         Use JWT strategy with callbacks to include user.id in session.

    3. Create `src/app/api/auth/[...nextauth]/route.ts`:
       ```typescript
       import { handlers } from '@/lib/auth'
       export const { GET, POST } = handlers
       ```

    4. Create `src/lib/dal.ts` (Data Access Layer — the REAL security layer):
       - Add 'use server' or import 'server-only' at top
       - Import { cache } from 'react'
       - Import { redirect } from 'next/navigation'
       - Import { auth } from '@/lib/auth'
       - Import { prisma } from '@/lib/prisma'
       - Export verifySession = cache(async () => {
           const session = await auth()
           if (!session?.user?.id) redirect('/login')
           return { isAuth: true, userId: session.user.id }
         })
       - Export getUser = cache(async () => {
           const session = await verifySession()
           return prisma.user.findUnique({
             where: { id: session.userId },
             select: { id: true, name: true, email: true } // NEVER include password
           })
         })
       - Export getUserByEmail(email: string) for use in auth config (no session required):
         ```typescript
         export async function getUserByEmail(email: string) {
           return prisma.user.findUnique({ where: { email } })
         }
         ```

    5. Create `middleware.ts` at project root (NOT in src/):
       ```typescript
       import NextAuth from 'next-auth'
       import { authConfig } from '@/lib/auth.config'

       export default NextAuth(authConfig).auth

       export const config = {
         matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
       }
       ```
       NOTE: Middleware uses authConfig (edge-compatible), NOT the full auth config with Prisma adapter.
       Middleware is for UX (redirects) only — real security is in the DAL.
  </action>
  <verify>
    - `npm run build` passes (middleware compiles for edge runtime)
    - `src/lib/auth.ts` exports auth, handlers, signIn, signOut
    - `src/lib/dal.ts` exports verifySession, getUser
    - `src/app/api/auth/[...nextauth]/route.ts` exports GET and POST
    - `middleware.ts` exists at project root (not in src/)
  </verify>
  <done>
    Auth.js v5 configured with split config pattern (edge-compatible auth.config.ts + full auth.ts with Prisma adapter). Credentials provider validates email/password with Zod and bcryptjs. DAL provides verifySession and getUser with React cache memoization. Middleware protects /dashboard routes. API route handler at /api/auth/[...nextauth] exposes auth endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for signup, login, and logout</name>
  <files>
    src/actions/auth.ts
    src/types/auth.ts
  </files>
  <action>
    1. Create `src/types/auth.ts` with shared types and validation schemas:
       ```typescript
       import { z } from 'zod'

       export const SignupSchema = z.object({
         name: z.string().min(2, 'Name must be at least 2 characters').max(50),
         email: z.string().email('Please enter a valid email address'),
         password: z.string()
           .min(8, 'Password must be at least 8 characters')
           .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
           .regex(/[0-9]/, 'Password must contain at least one number'),
       })

       export const LoginSchema = z.object({
         email: z.string().email('Please enter a valid email address'),
         password: z.string().min(1, 'Password is required'),
       })

       export type SignupInput = z.infer<typeof SignupSchema>
       export type LoginInput = z.infer<typeof LoginSchema>

       // Server action return type for form state
       export type AuthActionState = {
         errors?: Record<string, string[]>
         message?: string
       } | undefined
       ```

    2. Create `src/actions/auth.ts` with server actions:
       ```typescript
       'use server'

       import bcrypt from 'bcryptjs'
       import { signIn, signOut } from '@/lib/auth'
       import { prisma } from '@/lib/prisma'
       import { redirect } from 'next/navigation'
       import { AuthError } from 'next-auth'
       import { SignupSchema, LoginSchema, type AuthActionState } from '@/types/auth'
       ```

       **signup action:**
       - Accept `prevState: AuthActionState, formData: FormData` (useActionState compatible)
       - Parse and validate with SignupSchema.safeParse
       - On validation failure: return { errors: fieldErrors }
       - Check for existing user by email
       - If exists: return { errors: { email: ['An account with this email already exists'] } }
       - Hash password with bcryptjs (10 salt rounds)
       - Create user via prisma.user.create
       - Sign in automatically via signIn('credentials', { email, password, redirect: false })
       - Redirect to /dashboard

       **login action:**
       - Accept `prevState: AuthActionState, formData: FormData`
       - Parse and validate with LoginSchema.safeParse
       - On validation failure: return { errors: fieldErrors }
       - Call signIn('credentials', { email, password, redirectTo: '/dashboard' })
       - Wrap in try/catch for AuthError:
         - If error.type === 'CredentialsSignin': return { message: 'Invalid email or password' }
         - Otherwise: return { message: 'Something went wrong. Please try again.' }
       - IMPORTANT: signIn throws a NEXT_REDIRECT internally for successful login. Do NOT catch that as an error. Use this pattern:
         ```typescript
         try {
           await signIn('credentials', { ... })
         } catch (error) {
           if (error instanceof AuthError) {
             switch (error.type) {
               case 'CredentialsSignin':
                 return { message: 'Invalid email or password' }
               default:
                 return { message: 'Something went wrong.' }
             }
           }
           throw error // Re-throw non-auth errors (including NEXT_REDIRECT)
         }
         ```

       **logout action:**
       - Call signOut({ redirectTo: '/' })
  </action>
  <verify>
    - `npm run build` passes (server actions compile correctly)
    - `src/actions/auth.ts` has 'use server' directive at top
    - `src/actions/auth.ts` exports signup, login, logout functions
    - `src/types/auth.ts` exports SignupSchema, LoginSchema, AuthActionState
  </verify>
  <done>
    Three server actions created: signup (validates, checks duplicate email, hashes password, creates user, auto-signs-in), login (validates, authenticates via Auth.js, handles errors gracefully), logout (signs out and redirects home). All use Zod validation schemas. Proper error handling for AuthError types including NEXT_REDIRECT.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build login and signup pages with validated forms</name>
  <files>
    src/app/(auth)/layout.tsx
    src/app/(auth)/login/page.tsx
    src/app/(auth)/signup/page.tsx
    src/components/auth/login-form.tsx
    src/components/auth/signup-form.tsx
  </files>
  <action>
    1. Create `src/app/(auth)/layout.tsx` — centered auth layout:
       - Server component (no 'use client')
       - Render children centered on screen (flex, items-center, justify-center, min-h-screen)
       - Light background (bg-gray-50 or similar)
       - No navigation bar (auth pages are standalone)

    2. Create `src/components/auth/login-form.tsx` — client component:
       - 'use client' directive
       - Use useActionState (from 'react') with the login server action
       - Use React Hook Form with zodResolver for client-side validation (LoginSchema)
       - Use shadcn/ui components: Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter, Form, FormField, FormItem, FormLabel, FormControl, FormMessage, Input, Button
       - Form fields: email (type="email"), password (type="password")
       - Show server-side error message (from action state) above form or below submit button
       - Submit button with loading state (useFormStatus or form.formState.isSubmitting)
       - Link to signup page: "Don't have an account? Sign up"
       - Card title: "Welcome back" / Card description: "Sign in to your BidFlow account"

       For combining useActionState with React Hook Form:
       - Use the form's onSubmit to create FormData from validated values, then call the server action
       - OR use a simpler approach: use React Hook Form for client validation only, then submit as FormData to the server action

       Recommended approach (simpler, works well):
       ```tsx
       'use client'
       import { useActionState } from 'react'
       import { useForm } from 'react-hook-form'
       import { zodResolver } from '@hookform/resolvers/zod'
       import { login } from '@/actions/auth'
       import { LoginSchema, type LoginInput } from '@/types/auth'

       export function LoginForm() {
         const [state, formAction, isPending] = useActionState(login, undefined)
         const form = useForm<LoginInput>({
           resolver: zodResolver(LoginSchema),
           defaultValues: { email: '', password: '' },
         })

         // Client validates, then submits as FormData to server action
         const onSubmit = (data: LoginInput) => {
           const formData = new FormData()
           formData.append('email', data.email)
           formData.append('password', data.password)
           formAction(formData)
         }

         return (
           <Card className="w-full max-w-md">
             {/* ... form using shadcn/ui components */}
             {state?.message && <p className="text-sm text-red-500">{state.message}</p>}
             <Button type="submit" disabled={isPending}>
               {isPending ? 'Signing in...' : 'Sign in'}
             </Button>
           </Card>
         )
       }
       ```

    3. Create `src/components/auth/signup-form.tsx` — client component:
       - Same pattern as login form but with name field added
       - Use SignupSchema for validation
       - Fields: name, email (type="email"), password (type="password")
       - Show field-level errors from server action (state.errors.name, state.errors.email, etc.)
       - Link to login page: "Already have an account? Sign in"
       - Card title: "Create your account" / Card description: "Start winning tenders with BidFlow"

    4. Create `src/app/(auth)/login/page.tsx`:
       - Server component
       - Import and render LoginForm
       - Export metadata: { title: 'Sign In - BidFlow' }

    5. Create `src/app/(auth)/signup/page.tsx`:
       - Server component
       - Import and render SignupForm
       - Export metadata: { title: 'Sign Up - BidFlow' }
  </action>
  <verify>
    - `npm run build` passes
    - Login page renders at /login (check by visiting in browser or build output)
    - Signup page renders at /signup
    - Forms use shadcn/ui components (Card, Input, Button, Form)
    - Client-side validation prevents submission of empty/invalid fields
    - Login form shows error on invalid credentials
    - Signup form shows field-level errors
  </verify>
  <done>
    Auth UI complete: centered auth layout, login page with email/password form (client-side Zod validation + server-side error display), signup page with name/email/password form (field-level validation errors). Both use shadcn/ui Card, Form, Input, Button components. Links between login and signup pages. Loading states on submit buttons.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. Visit /login — see login form with email and password fields
3. Visit /signup — see signup form with name, email, and password fields
4. Submit signup with valid data — user created, redirected to /dashboard
5. Visit /login with valid credentials — redirected to /dashboard
6. Visit /dashboard without session — redirected to /login
7. Session persists across page refresh (stay on /dashboard)
8. Invalid login credentials show error message (not crash)
9. Duplicate email signup shows "already exists" error
</verification>

<success_criteria>
- Auth.js v5 configured with credentials provider and JWT session strategy
- DAL provides verifySession() and getUser() with React cache memoization
- Middleware protects /dashboard routes, redirects unauthenticated to /login
- Server actions handle signup (with duplicate check), login (with error handling), logout
- Login and signup pages use shadcn/ui forms with client + server validation
- Session persists across browser refresh via encrypted JWT cookie
- No password hashes ever returned to client
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
